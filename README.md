# Тестовое задание VK Core Infrastructure

В задании нужно написать парсер, так что я решил совместить полезное с приятным.

Ранее я работал с библиотекой Parsec на Haskell и мне очень понравилась 
лаконичность при использовании, так что я попробовал реализовать часть функционала
парсер-комбинаторов на C++.

Приведу небольшой пример. Ниже приведен код на Haskell, который позволяет пасрить 
последовательность букв или цифр, между которыми стоит произвольное
число пробелов, либо вместо последовательности написано empty. С помощью Parsec
это можно реализовать следующим образом:
```cpp
(many (spaces >> alphaNum)) <|> string "empty"
```

С помощью реализованного мной функционала тоже самое можно написать на C++ так:
```cpp
many(spaces() >> alphaNum()) | prefix_parser("empty")
```

Мне нравится функциональный стиль, так что я рад, что получилось сделать использование
библиотеки таким образом, что синтаксис базовых конструкций почти не отличается от 
Haskell.

Собственно, грамматика калькулятора с римскими числами парсится с помощью парсер-комбинаторов.
Код, специфичный для задачи лежит в файлах `CalcParser.hpp` и `RomanNumeralsParser.hpp`,
а реализация библиотеки в папке `Parsec`.

Судя по тому, что я прочитал в интернете, есть разные способы понимать, что такое
"правильное" римское число сейчас. Я выбрал вариант, в котором все цифры должны
идти в порядке невозрастания (Например, нельзя написать `VM`), но с использованием 
правил вычитания (Например, `IX` корректная запись числа 9).

Также некоторые цифры можно использовать не больше 1 раза, например, `V`, а некоторые
до 3 раз, например, `I`. Из этого следует, что, например, число `IIII` будет некоррректным,
вместо него следует использовать `IV`. Однако, цифру `M` я разрешил повторять любое количество раз
чтобы была возможность записать большие по значению числа.

Описание BNF-грамматики лежит в файле `grammar.txt`. Реализация поддерживает выбрасывание
исключения в случае переполнения знакового 64-битного типа.

Жаль, что в задании закреплен 17-ый стандарт плюсов, так как из-за обилия шаблонов в реализации
библиотеки, хотелось бы воспользоваться концептами из 20-го стандарта для получения дополнительных
гарантий на типы, иначе сейчас могут быть огромные сообщения об ошибках, если отдать в
аргумент некорректную лямбду, например.